---
title: 小程序开发踩的坑
date: 2017-09-12 11:28:54
tags: 小程序
---
## 1.setData
setData 是小程序里用的最频繁的接口，然后就会引起一系列的性能问题，欲哭无泪。

#工作原理
先来介绍一下setData的工作原理（官网上抄的）
小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。
在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。
当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。
即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。

而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。
同一进程内的 WebView 实际上会共享一个 JS VM，如果 WebView 内 JS 线程正在执行渲染或其他逻辑，
会影响 evaluateJavascript 脚本的实际执行时间，另外多个 WebView 也会抢占 JS VM 的执行权限；
另外还有 JS 本身的编译执行耗时，都是影响数据传输速度的因素。


#常见不科学操作
a.频繁地setData
在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果：

·Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，
未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；
·渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，
视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；

b.每次 setData 都传递大量新数据

由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript 脚本过程，当数据量过大时会增加脚本的编译执行时间，
占用 WebView JS 线程，


c. 后台态页面进行 setData

当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，
另外后台态页面去setData也会抢占前台页面的执行。



#实际工作中遇到的问题
1.开发的时候接手了一个列表页，遇到了很多坑
a.列表数据多的时候，点击事件特别慢
我使用setData来控制显示和隐藏的，而一旦数据量大的时候，点击事件里面的setData 执行一次就需要很长时间，所以列表页的所有点击事件，都被我们
测试妹妹吐槽，测试妹妹用一个很古老的华为手机来测试点击事件，导致现在开发的时候，每次都要借手机来看看性能

改进方法，
后面我们想了很多种解决方法，但是依旧是逃脱不了setData的魔咒，最接近成功的一次是，我们用hover来控制子元素的显示隐藏，但是手机端查看的时候
仿佛是被附身了，各种怪异。
真正成功的方法，要出现了，我们部门十年的大神，说用radio的check来控制元素的隐藏与显示，于是，登登登登，华丽丽地解决了点击事件。

大概的代码就是
<pre>
&lt;radio-group&gt;
    &lt;block wx:for="{{logs}}" wx:for-item="log" wx:key="*this"&gt;
      &lt;radio name="xx"&gt;
        &lt;view class="box"&gt;
          &lt;text class="log-item" data-index="{{index}}"&gt;{{index + 1}}. 点击切换&lt;/text&gt;
          &lt;text class="x"&gt;{{log.text}}&lt;/text&gt;
        &lt;/view&gt;
      &lt;/radio&gt;
    &lt;/block&gt;
&lt;/radio-group&gt;
</pre>

b.setData里面的数据太大，导致报错
我之前在开发的时候，小程序的调试框框老是报dom超了，或者数据大了，然后大家都忽略了这个问题，上线之后，发现数据一大，页面直接挂。
后面在开发的时候，删掉了很多dom节点和js数据。

